{"ast":null,"code":"import TileResolver from './TileResolver.js';\nexport function createBackgroundLayer(level, tiles, sprites) {\n  const resolver = new TileResolver(tiles);\n  const buffer = document.createElement('canvas');\n  buffer.width = 550;\n  buffer.height = 640;\n  const context = buffer.getContext('2d');\n  function redraw(startIndex, endIndex) {\n    context.clearRect(0, 0, buffer.width, buffer.height);\n    for (let x = startIndex; x <= endIndex; ++x) {\n      const col = tiles.grid[x];\n      if (col) {\n        col.forEach((tile, y) => {\n          if (sprites.animation.has(tile.name)) {\n            sprites.drawAnim(tile.name, context, x - startIndex, y, level.totalTime);\n          } else {\n            sprites.drawtile(tile.name, context, x - startIndex, y);\n          }\n        });\n      }\n    }\n  }\n  return function drawBackgroundLayer(context, camera) {\n    const drawWidth = resolver.toIndex(camera.size.x);\n    const drawFrom = resolver.toIndex(camera.pos.x);\n    const drawTo = drawFrom + drawWidth;\n    redraw(drawFrom, drawTo); //+screenwidth here\n    context.drawImage(buffer, -camera.pos.x % 16, -camera.pos.y);\n  };\n}\nexport function createSpriteLayer(entities) {\n  let width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  let height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 64;\n  const spriteBuffer = document.createElement('canvas');\n  spriteBuffer.width = width;\n  spriteBuffer.height = height;\n  const spriteBufferContext = spriteBuffer.getContext('2d');\n  return function drawSpriteLayer(context, camera) {\n    entities.forEach(entity => {\n      spriteBufferContext.clearRect(0, 0, width, height);\n      entity.draw(spriteBufferContext);\n      context.drawImage(spriteBuffer, entity.pos.x - camera.pos.x,\n      //here\n      entity.pos.y - camera.pos.y); //here\n    });\n  };\n}\n\n// export function createCollisionLayer(level){\n// \tconst resolvedTiles=[];\n\n// \tconst tileResolver=level.tileCollider.tiles;\n// \tconst tileSize=tileResolver.tileSize;\n\n// \tconst getByIndexOriginal=tileResolver.getByIndex;\n// \ttileResolver.getByIndex=function getByIndexFake(x,y){\n// \t\tresolvedTiles.push({x,y});\n// \t\treturn getByIndexOriginal.call(tileResolver,x,y);\n// \t}\n\n// \treturn function drawCollision(context){\n// \t\tcontext.strokeStyle='blue';\n// \t\tresolvedTiles.forEach(({x,y})=>{\n// \t\t\tcontext.beginPath();\n// \t\t\tcontext.rect(\n// \t\t\t\tx*tileSize-camera.pos.x, //here\n// \t\t\t\ty*tileSize-camera.pos.y, //here\n// \t\t\t\ttileSize,tileSize);\n// \t\t\t//context.stroke();\n// \t\t\t//console.log('Would draw',x,y);\n// \t\t});\n\n// \t\tcontext.strokeStyle='red';\n// \t\tlevel.entities.forEach(entity=>{\n// \t\t\tcontext.beginPath();\n// \t\t\tcontext.rect(\n// \t\t\t\tentity.pos.x-camera.pos.x, //here\n// \t\t\t\tentity.pos.y-camera.pos.y, //here\n// \t\t\t\tentity.size.x,\n// \t\t\t\tentity.size.y);\n// \t\t\t//context.stroke();\n// \t\t})\n\n// \t\tresolvedTiles.length=0;\n// \t};\n// }\n\nexport function createCameraLayer(cameraToDraw) {\n  return function drawCameraRect(context, fromCamera) {\n    context.strokeStyle = 'purple';\n    context.beginPath();\n    context.rect(cameraToDraw.pos.x - fromCamera.pos.x, cameraToDraw.pos.y - fromCamera.pos.y, cameraToDraw.size.x, cameraToDraw.size.y);\n    context.stroke();\n  };\n}","map":{"version":3,"names":["TileResolver","createBackgroundLayer","level","tiles","sprites","resolver","buffer","document","createElement","width","height","context","getContext","redraw","startIndex","endIndex","clearRect","x","col","grid","forEach","tile","y","animation","has","name","drawAnim","totalTime","drawtile","drawBackgroundLayer","camera","drawWidth","toIndex","size","drawFrom","pos","drawTo","drawImage","createSpriteLayer","entities","spriteBuffer","spriteBufferContext","drawSpriteLayer","entity","draw","createCameraLayer","cameraToDraw","drawCameraRect","fromCamera","strokeStyle","beginPath","rect","stroke"],"sources":["/home/kaiyang7766/Desktop/portfolio/src/js/layers.js"],"sourcesContent":["import TileResolver from './TileResolver.js';\n\nexport function createBackgroundLayer (level,tiles, sprites){\n\tconst resolver = new TileResolver(tiles);\n\n\tconst buffer=document.createElement('canvas');\n \tbuffer.width=550;\n \tbuffer.height=640;\n \tconst context=buffer.getContext('2d');\n\n \tfunction redraw(startIndex,endIndex){\n \t\tcontext.clearRect(0,0,buffer.width,buffer.height);\n \t\tfor (let x=startIndex;x<=endIndex;++x){\n \t\t\tconst col = tiles.grid[x];\n \t\t\tif (col){\n \t\t\t\tcol.forEach((tile,y)=>{\n \t\t\t\t\tif (sprites.animation.has(tile.name)){\n \t\t\t\t\t\tsprites.drawAnim(tile.name,context,x-startIndex,y,level.totalTime);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tsprites.drawtile(tile.name,context,x-startIndex,y);\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t}\n \t}\n\n \treturn function drawBackgroundLayer(context,camera){\n \t\tconst drawWidth=resolver.toIndex(camera.size.x);\n \t\tconst drawFrom=resolver.toIndex(camera.pos.x);\n \t\tconst drawTo=drawFrom+drawWidth;\n \t\tredraw(drawFrom,drawTo);  //+screenwidth here\n \t\tcontext.drawImage(buffer,\n \t\t\t-camera.pos.x%16,\n \t\t\t-camera.pos.y);\n \t};\n}\n\nexport function createSpriteLayer(entities, width=200,height=64){\n\tconst spriteBuffer=document.createElement('canvas');\n\tspriteBuffer.width=width;\n\tspriteBuffer.height=height;\n\tconst spriteBufferContext=spriteBuffer.getContext('2d');\n\n\treturn function drawSpriteLayer(context,camera){\n\t\tentities.forEach(entity=>{\n\t\t\tspriteBufferContext.clearRect(0,0,width,height);\n\n\t\t\tentity.draw(spriteBufferContext);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tspriteBuffer,\n\t\t\t\tentity.pos.x-camera.pos.x,  //here\n\t\t\t\tentity.pos.y-camera.pos.y); //here\n\t\t});\n\t};\n}\n\n// export function createCollisionLayer(level){\n// \tconst resolvedTiles=[];\n\n// \tconst tileResolver=level.tileCollider.tiles;\n// \tconst tileSize=tileResolver.tileSize;\n\n// \tconst getByIndexOriginal=tileResolver.getByIndex;\n// \ttileResolver.getByIndex=function getByIndexFake(x,y){\n// \t\tresolvedTiles.push({x,y});\n// \t\treturn getByIndexOriginal.call(tileResolver,x,y);\n// \t}\n\n// \treturn function drawCollision(context){\n// \t\tcontext.strokeStyle='blue';\n// \t\tresolvedTiles.forEach(({x,y})=>{\n// \t\t\tcontext.beginPath();\n// \t\t\tcontext.rect(\n// \t\t\t\tx*tileSize-camera.pos.x, //here\n// \t\t\t\ty*tileSize-camera.pos.y, //here\n// \t\t\t\ttileSize,tileSize);\n// \t\t\t//context.stroke();\n// \t\t\t//console.log('Would draw',x,y);\n// \t\t});\n\n// \t\tcontext.strokeStyle='red';\n// \t\tlevel.entities.forEach(entity=>{\n// \t\t\tcontext.beginPath();\n// \t\t\tcontext.rect(\n// \t\t\t\tentity.pos.x-camera.pos.x, //here\n// \t\t\t\tentity.pos.y-camera.pos.y, //here\n// \t\t\t\tentity.size.x,\n// \t\t\t\tentity.size.y);\n// \t\t\t//context.stroke();\n// \t\t})\n\n// \t\tresolvedTiles.length=0;\n// \t};\n// }\n\nexport function createCameraLayer(cameraToDraw){\n\treturn function drawCameraRect(context,fromCamera){\n\t\tcontext.strokeStyle='purple';\n\t\tcontext.beginPath();\n\t\t\tcontext.rect(\n\t\t\t\tcameraToDraw.pos.x-fromCamera.pos.x,\n\t\t\t\tcameraToDraw.pos.y-fromCamera.pos.y,\n\t\t\t\tcameraToDraw.size.x,\n\t\t\t\tcameraToDraw.size.y);\n\t\t\tcontext.stroke();\n\t};\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}