{"ast":null,"code":"import Level from '../Level.js';\nimport { createBackgroundLayer, createSpriteLayer } from '../layers.js';\nimport { loadJSON, loadSpriteSheet } from '../loaders.js';\nimport { Matrix } from '../math.js';\nexport function loadLevel(name) {\n  return loadJSON(`./levels/${name}.json`).then(levelSpec => Promise.all([levelSpec, loadSpriteSheet(levelSpec.spriteSheet)])).then(_ref => {\n    let [levelSpec, sprites] = _ref;\n    const level = new Level();\n    const mergedTiles = levelSpec.layers.reduce((mergedTiles, layerSpec) => {\n      return mergedTiles.concat(layerSpec.tiles);\n    }, []);\n    const collisionGrid = createCollisionGrid(mergedTiles, levelSpec.patterns);\n    level.setCollisionGrid(collisionGrid);\n    levelSpec.layers.forEach(layer => {\n      const backgroundGrid = createBackgroundGrid(layer.tiles, levelSpec.patterns);\n      const backgroundLayer = createBackgroundLayer(level, backgroundGrid, sprites);\n      level.comp.layers.push(backgroundLayer);\n    });\n    const spriteLayer = createSpriteLayer(level.entities);\n    level.comp.layers.push(spriteLayer);\n    return level;\n  });\n}\nfunction createCollisionGrid(tiles, patterns) {\n  const grid = new Matrix();\n  for (const {\n    tile,\n    x,\n    y\n  } of expandTiles(tiles, patterns)) {\n    grid.set(x, y, {\n      type: tile.type\n    });\n  }\n  return grid;\n}\nfunction createBackgroundGrid(tiles, patterns) {\n  const grid = new Matrix();\n  for (const {\n    tile,\n    x,\n    y\n  } of expandTiles(tiles, patterns)) {\n    grid.set(x, y, {\n      name: tile.name\n    });\n  }\n  return grid;\n}\nfunction* expandSpan(xStart, xLen, yStart, yLen) {\n  const xEnd = xStart + xLen;\n  const yEnd = yStart + yLen;\n  for (let x = xStart; x < xEnd; ++x) {\n    for (let y = yStart; y < yEnd; ++y) {\n      yield {\n        x,\n        y\n      };\n    }\n  }\n}\nfunction expandRange(range) {\n  if (range.length === 4) {\n    const [xStart, xLen, yStart, yLen] = range;\n    return expandSpan(xStart, xLen, yStart, yLen);\n  } else if (range.length === 3) {\n    const [xStart, xLen, yStart] = range;\n    return expandSpan(xStart, xLen, yStart, 1);\n  } else if (range.length === 2) {\n    const [xStart, yStart] = range;\n    return expandSpan(xStart, 1, yStart, 1);\n  }\n}\nfunction* expandRanges(ranges) {\n  for (const range of ranges) {\n    for (const item of expandRange(range)) {\n      yield item;\n    }\n  }\n}\nfunction expandTiles(tiles, patterns) {\n  const expandedTiles = [];\n  function walkTiles(tiles, offsetX, offsetY) {\n    for (const tile of tiles) {\n      for (const {\n        x,\n        y\n      } of expandRanges(tile.ranges)) {\n        const derivedX = x + offsetX;\n        const derivedY = y + offsetY;\n        if (tile.pattern) {\n          const tiles = patterns[tile.pattern].tiles;\n          walkTiles(tiles, derivedX, derivedY);\n        } else {\n          expandedTiles.push({\n            tile,\n            x: derivedX,\n            y: derivedY\n          });\n        }\n      }\n    }\n  }\n  walkTiles(tiles, 0, 0);\n  return expandedTiles;\n}","map":{"version":3,"names":["Level","createBackgroundLayer","createSpriteLayer","loadJSON","loadSpriteSheet","Matrix","loadLevel","name","then","levelSpec","Promise","all","spriteSheet","sprites","level","mergedTiles","layers","reduce","layerSpec","concat","tiles","collisionGrid","createCollisionGrid","patterns","setCollisionGrid","forEach","layer","backgroundGrid","createBackgroundGrid","backgroundLayer","comp","push","spriteLayer","entities","grid","tile","x","y","expandTiles","set","type","expandSpan","xStart","xLen","yStart","yLen","xEnd","yEnd","expandRange","range","length","expandRanges","ranges","item","expandedTiles","walkTiles","offsetX","offsetY","derivedX","derivedY","pattern"],"sources":["/home/kaiyang7766/Desktop/portfolio/src/js/loaders/level.js"],"sourcesContent":["import Level from '../Level.js';\nimport {createBackgroundLayer, createSpriteLayer} from '../layers.js';\nimport {loadJSON, loadSpriteSheet} from '../loaders.js';\nimport {Matrix} from '../math.js';\n\nexport function loadLevel(name){\n\treturn loadJSON(`./levels/${name}.json`)\n\t.then(levelSpec => Promise.all([\n\t\tlevelSpec,\n\t\tloadSpriteSheet(levelSpec.spriteSheet),\n\t]))\n\t.then(([levelSpec,sprites])=>{\n\t\tconst level = new Level();\n\n\t\tconst mergedTiles=levelSpec.layers.reduce((mergedTiles,layerSpec)=>{\n\t\t\treturn mergedTiles.concat(layerSpec.tiles);\n\t\t}, []);\n\t\tconst collisionGrid=createCollisionGrid(mergedTiles,levelSpec.patterns)\n\t\tlevel.setCollisionGrid(collisionGrid);\n\n\t\tlevelSpec.layers.forEach(layer=>{\n\t\tconst backgroundGrid=createBackgroundGrid(layer.tiles,levelSpec.patterns)\n \t\tconst backgroundLayer=createBackgroundLayer(level,backgroundGrid, sprites);\n \t\tlevel.comp.layers.push(backgroundLayer);\n \t\t});\n\n \t\tconst spriteLayer=createSpriteLayer(level.entities);\n \t\tlevel.comp.layers.push(spriteLayer);\n\n \t\treturn level;\n\t})\n}\n\nfunction createCollisionGrid(tiles,patterns){\n\tconst grid=new Matrix();\n\n\tfor (const {tile,x,y} of expandTiles(tiles,patterns)){\n\t\t\tgrid.set(x,y,{type:tile.type});\n\t\t}\n\n\t\treturn grid;\n}\n\nfunction createBackgroundGrid(tiles,patterns){\n\tconst grid=new Matrix();\n\n\tfor (const {tile,x,y} of expandTiles(tiles,patterns)){\n\t\t\tgrid.set(x,y,{name:tile.name});\n\t\t}\n\n\t\treturn grid;\n}\n\nfunction* expandSpan(xStart,xLen,yStart,yLen){\n\tconst xEnd=xStart+xLen;\n\tconst yEnd=yStart+yLen;\n\tfor (let x=xStart;x<xEnd;++x){\n\t\tfor (let y=yStart;y<yEnd;++y){\n\t\t\tyield {x,y};\n\t\t}\n\t}\n}\n\nfunction expandRange(range){\n\tif (range.length===4){\n\t\tconst [xStart,xLen,yStart,yLen]=range;\n\t\treturn expandSpan(xStart,xLen,yStart,yLen);\n\t}\n\n\telse if (range.length===3){\n\t\tconst [xStart,xLen,yStart]=range;\n\t\treturn expandSpan(xStart,xLen,yStart,1);\n\t}\n\n\telse if (range.length===2){\n\t\tconst [xStart,yStart]=range;\n\t\treturn expandSpan(xStart,1,yStart,1);\n\t}\n}\n\nfunction* expandRanges(ranges){\n\tfor (const range of ranges){\n\t\tfor (const item of expandRange(range)){\n\t\t\tyield item;\n\t\t}\n\t}\n}\n\nfunction expandTiles(tiles,patterns){\n\tconst expandedTiles =[];\n\n\tfunction walkTiles(tiles,offsetX,offsetY){\n\t\tfor (const tile of tiles){\n\t\t\tfor (const {x,y} of expandRanges(tile.ranges)){\n\t\t\t\tconst derivedX=x+offsetX;\n\t\t\t\tconst derivedY=y+offsetY;\n\n\t\t\t\tif (tile.pattern){\n\t\t\t\t\t\tconst tiles=patterns[tile.pattern].tiles;\n\t\t\t\t\t\twalkTiles(tiles,derivedX,derivedY);\n\t\t\t\t\t} else{\n\t\t\t\t\t\texpandedTiles.push({\n\t\t\t\t\t\t\ttile,\n\t\t\t\t\t\t\tx:derivedX,\n\t\t\t\t\t\t\ty:derivedY,\n\t\t\t\t\t\t}); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\twalkTiles(tiles,0,0);\n\n\treturn expandedTiles;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}